<?php
module_load_include('inc', 'nycc_og', 'nycc_og.email_integration');
/*TODO LIST
 *Add validation to ensure max count is >= current confirmed riders
 *confirm profile edit URL
  *add hook to catch update to max and process waitlist
 *Fix Rules and re-add invocation
 */

function nycc_og_menu() {
  $items = array();
  $items['admin/config/nycc/nycc_og'] = array(
      'title' => 'NYCC Organic Groups  Settings',
      'description' => 'configure organic groups integration',
      'page callback' => 'drupal_get_form',
      'file' => 'nycc_og.admin.inc',
      'access arguments' => array('administer nycc_og'),
      'type' => MENU_NORMAL_ITEM,
      'access callback' => TRUE,
      'page arguments' => array('nycc_og_admin'),
    );
  
  $items['node/%/join_group'] = array(
    'title' => 'Join Group',
    'page callback' => 'nycc_join_group_callback',
    'access callback' => TRUE,
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
  );
  

  $items['node/%/withdraw_group'] = array(
    'title' => 'Withdraw From Group',
    'page callback' => 'nycc_withdraw_from_group_callback',
    'access callback' => TRUE,
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
  );  
  
  $url_sufix = variable_get('nycc_og_inbound_url', '');
  if ($url_sufix != '') {
    $items[$url_sufix] = array(
      'title' => t('NYCC Group Email'),
      'description' => t('Group email'),
      'type' => MENU_CALLBACK,
      'page callback' => 'nycc_og_group_email_callback',
      'access callback' => TRUE,
    );    
  } else {
    watchdog('nycc_og', 'could not retrieve variable for url_suffix: @suffix. Inbound emails will not be processed', array('@suffix' => $url_sufix), WATCHDOG_ERROR) ; 
  }
  
  return $items;
}


function nycc_og_permission() {
  return array(
    'administer nycc og' => array(
      'title' => t('administer nycc og'),
      'description' => t('administer nycc og'),
        ), 
    );
}
//Functions related to OG Groups for SIGs
////Functions related to OG Groups for SIGs

/* function used to add a member to the group as either a rider or a waitlister.
 * function can be called from url (in which case $user_id will be null) or directly from code (in which case a $user_id is required)
 * if function is called directly then all messages are suppressed.
 */

 
 function nycc_join_group_callback($gid) {
  try {
    $result = nycc_og_join_group($gid);
    drupal_set_message($result);
  } catch (NyccException $e) {
    drupal_set_message( $e->getMessage(),  "error");
    $goto_path =$e->getGotoPath();
    $goto_qs = $e->getGotoQeuryString();
    if(isset($goto_path) && (!empty($goto_qs))) {
      drupal_goto($goto_path, $goto_qs);
    } elseif(isset($goto_path)) {
      drupal_goto($goto_path);
    }
  }
  drupal_goto("node/$gid");
  
}
 
 
 /* function used to add a member to the group as either a rider or a waitlister.
 * function can be called from url (in which case $user_id will be null) or directly from code (in which case a $user_id is required)
 * if function is called directly then all messages are suppressed.
 */
function nycc_og_join_group($nid, $user_id = null) {
  if (variable_get('nycc_og_debug_to_log', '1') == 1) {
    $debug = TRUE;
  }
  else {
    $debug = FALSE;
  }

  $grp_node = nycc_og_get_group_object($nid);
  if (!isset($grp_node)) {
    watchdog("nycc_og", "nycc_og_join_group - no NID was passed. Cancelling function.", array(), WATCHDOG_WARNING);
    throw new NyccException ("nycc_og_join_group: This operation could not be completed. No Group ID was passed.");   
  }
  
  $user = nycc_get_user_object($user_id);  
  if(!isset($user)) {
    watchdog("nycc_og", "nycc_og_join_group - Unable to load user. Cancelling function.", array(), WATCHDOG_WARNING);
    throw new NyccException ("nycc_og_join_group: This operation could not be completed. Unable to load user $user_id.");
  }
  
  $user_id = $user->uid;
  
  if(nycc_og_is_confirmed($nid, $user_id)) {
    if ($debug ) watchdog('nycc_og',  'cancelling join for user @uid because they are already confirmed', array('@uid' => $user->uid), WATCHDOG_NOTICE) ;
    throw new NyccException ("You cannot join this group because you are already a confirmed member");
  }

  if(nycc_og_is_waiter($nid, $user_id)) {
    if ($debug ) watchdog('nycc_og',  'cancelling join for user @uid because they are already waitlisted', array('@uid' => $user->uid), WATCHDOG_NOTICE) ;    
    throw new NyccException ("You cannot join this group because you are already on the waitlist");
  }  

  if(nycc_og_is_captain_or_leader_or_admin($nid, $user_id)) {
    if ($debug ) watchdog('nycc_og',  'cancelling join for user @uid because they are a leader or captain', array('@uid' => $user->uid), WATCHDOG_NOTICE) ;
    throw new NyccException ("You cannot join this group because you are already a leader or captain");
  }

  
  $group = node_load($nid);
  if (!isset($group)) {
    watchdog("nycc_og", "nycc_og_join_group - Unable to load group with ID $nid. Cancelling function.", array(), WATCHDOG_WARNING);
    throw new NyccException ("Unable to load group with ID $nid.");
  }
  
  $grp_signup_enable_time = nycc_field_get_property_text_value($group, 'field_group_reg_open_date');
  if ($debug ) watchdog('nycc_og',  'Group signup enable time is @time.', array('@time' => $grp_signup_enable_time), WATCHDOG_NOTICE) ;
  
  if ($grp_signup_enable_time != '' && $grp_signup_enable_time > REQUEST_TIME) {    
    throw new NyccException ("Error! Registration will open at $grp_signup_enable_time. Please revisit this page at that time.");
  }


  if(!nycc_has_required_profile_info($user)) {
    if ($debug ) watchdog('nycc_og',  'cancelling join for user @uid because profile is missing info.', array('@uid' => $user->uid), WATCHDOG_NOTICE) ;
    throw NyccException::with_goto("Please update your Emergency Contact No and Name (required for SIG signup).", "user/" . $user->uid . "/edit/profile", array('query'=>drupal_get_destination()));
    }
    //TODO: Confirm this URL is still correct  

  $max_spots = nycc_field_get_property_text_value($group, 'field_group_max_participants');
  $rider_rid = variable_get('nycc_og_rider_role_id', '5');
  $waiter_rid = variable_get('nycc_og_waiter_role_id', '7');
  
  // Add the user to the group
  try {
    if ($debug ) watchdog('nycc_og',  'Attempting to add user @uid to group @nid.', array('@uid' => $user_id, '@nid' => $nid), WATCHDOG_NOTICE) ;
    og_group('node', $nid,
           array(
            "entity type" => "user",
            "entity" => $user,
            "membership type" => OG_MEMBERSHIP_TYPE_DEFAULT,
          )
        );
    
    if ($debug ) watchdog('nycc_og',  'Successfully added user @uid to group @nid.', array('@uid' => $user_id, '@nid' => $nid), WATCHDOG_NOTICE) ;    
    
    
    $rider_count = nycc_og_get_user_count_by_role($nid, $rider_rid);
    if ($debug ) watchdog('nycc_og',  'Count of current riders is @count and max is set to @max.', array('@count' => $rider_count, '@max' => $max_spots), WATCHDOG_NOTICE) ;    
    if ($max_spots == '' || $rider_count < $max_spots) {
      og_role_grant('node', $nid, $user->uid, $rider_rid);
      if ($debug )
        watchdog('nycc_og',  'Confirming user @uid to group @nid.', array('@uid' => $user->uid, '@nid' => $nid), WATCHDOG_NOTICE) ;
     
     return "Congratulations! You are now confirmed as a member of this group. You should recieve an email confirming this.";
      
      rules_invoke_event('nycc_og_member_confirmed',  $group, $user);    
    } else {
      //Add waitlister role to user
      og_role_grant('node', $nid, $user->uid, $waiter_rid);
      
      if ($debug )
        watchdog('nycc_og',  'Waitlisting user @uid to group @nid.', array('@uid' => $user->uid, '@nid' => $nid), WATCHDOG_NOTICE) ;
      
      $waiter_count = nycc_og_get_user_count_by_role($nid, $waiter_rid);
      
      rules_invoke_event('nycc_og_member_waitlisted', $group, $user);
      
     return "You are # $waiter_count on the waitlist for this group. You'll receive an email confirming this. If a spot opens you'll be automatically added and will be notified by email";
    }
    return;
  } catch (Exception $e) {
    throw new NyccException("Error: Unable added user with $uid to group with ID $nid.", 0 ,  $e);
  }
}
 
function nycc_og_test_exception($uid) {
  try {
      throw NyccException::with_goto("Please update your Emergency Contact No and Name (required for SIG signup).", "user/" . $user->uid . "/edit/profile", array('query'=>drupal_get_destination()));
  } catch (NyccException $e) {
    dpm($e->getGotoQeuryString());
  }
}
 
 
function nycc_withdraw_from_group_callback($gid) {
  try {
    watchdog('nycc_og', 'withdraw called at ' . microtime()); 
    $result = nycc_og_withdraw_from_group($gid);
    drupal_set_message($result);
  } catch (NyccException $e) {
    drupal_set_message( $e->getMessage(),  "error");
    $goto_path =$e->getGotoPath();
    $goto_qs = $e->getGotoQeuryString();
    if(isset($goto_path) && (!empty($goto_qs))) {
      drupal_goto($goto_path, $goto_qs);
    } elseif(isset($goto_path)) {
      drupal_goto($goto_path);
    }
  } 
  drupal_goto("node/$gid");
}

function nycc_og_withdraw_from_group($nid, $user_id = null) {
  if (variable_get('nycc_og_debug_to_log', '1') == 1) {
    $debug = TRUE;
  }
  else {
    $debug = FALSE;
  }

  $grp_node = nycc_og_get_group_object($nid);
  if (!isset($grp_node)) {
    watchdog("nycc_og", "nycc_og_withdraw_from_group - no NID was passed. Cancelling function.", array(), WATCHDOG_WARNING);
    throw new NyccException("nycc_og_withdraw_from_group: This operation could not be completed. No Group ID was passed.");   
  }
  
  $user = nycc_get_user_object($user_id);
  if(!isset($user)) {
    watchdog("nycc_og", "nycc_og_withdraw_from_group - Unable to load user. Cancelling function.", array(), WATCHDOG_WARNING);
    throw new NyccException("nycc_og_withdraw_from_group: This operation could not be completed. Unable to load user $user_id.");
  }
  $user_id = $user->uid;
  
  if(!nycc_og_is_member($nid, $user_id)) {
    throw new NyccException( "Withdraw failed. You are not a member of this group.");
  }
  
  if(nycc_og_is_captain_or_leader_or_admin($nid, $user_id)) {
    throw new NyccException ("You cannot withdraw from this group because you are a leader or captain");
  } 
    
   if(nycc_og_is_leader($nid, $user_id) || nycc_og_is_captain($nid, $user_id) || nycc_og_is_admin($nid, $user_id)) {
    throw new NyccException( "Withdraw failed. You are leader or captain of this group.");
  }
  
  $membership = og_get_membership('node', $grp_node->nid, 'user', $user_id);
  if(isset($membership)) {
    $was_confirmed = nycc_og_is_confirmed($nid, $user_id);
    $was_waiter = nycc_og_is_waiter($nid, $user_id);
    //remove the membership
    
    try {
      og_membership_delete($membership->id);
      
      if(!nycc_og_is_rider_or_waiter($grp_node->nid, $user_id)) {
        if($was_confirmed) {
          rules_invoke_event('nycc_og_confirmed_member_withdraws',  $grp_node, $user); 
          if ($debug ) watchdog('nycc_og',  'Removing user @uid from group @nid.', array('@uid' => $user_id, '@nid' => $nid), WATCHDOG_NOTICE) ;
          return "You have withdrawn from this group. You should recieve an email confirming this.";
        }
        if($was_waiter) { 
          rules_invoke_event('nycc_og_waitlisted_member_withdraws',  $grp_node, $user); 
          if ($debug ) watchdog('nycc_og',  'Removing user @uid from waitlist on group @nid.', array('@uid' => $user_id, '@nid' => $nid), WATCHDOG_NOTICE) ;
          return "You have withdrawn from the waitlist of this group. You should recieve an email confirming this.";
        }
      } //if delete was successful
      else {
        watchdog('nycc_og',  'Unable to delete membership for user: @uid from group @nid.', array('@uid' => $user_id, '@nid' => $nid), WATCHDOG_ERROR) ;
        throw new NyccException( "Unable to withdraw you from this group. Please try again or contact the webmaster");
      }
    } catch (Exception $e) {
      watchdog('nycc_og',  'Unable to delete membership for user: @uid for group @gid. Messages is <pre>@message</pre>', array('@uid' => $uid, '@gid' => $gid, '@message' => $e->getMessage()), WATCHDOG_ERROR);
      throw new NyccException( "Unable to delete membership for user: $uid for group $gid.", 0, $e);
    }
  } else {
    watchdog('nycc_og',  'Unable to load membership for user: @uid from group @nid.', array('@uid' => $user_id, '@nid' => $nid), WATCHDOG_ERROR) ;
    throw new NyccException( "Unable to load your membership. Please try again or contact the webmaster");            
  }
  return '';
}



//DISPLAY RELATED FUNCTIONS
function nycc_og_get_buttons($nid = null, $user_id = null) {
  /*
   *Buttons include:
   *  Register - Paid Member, not currently group member, Has available spots Signup is enabled- Calls Join_group
   *  Add to Waitlist - Paid Member, not currently group member, No available spots, Signup is enabled - Calls Join_group
   *  Withdraw - Is rider, not leader, captain or admin - calls nycc_og_withdraw_from_group
   *  Withdraw from Waitlist - Is waitlisted, not leader, captain, or admin - calls nycc_og_withdraw_from_group
   */
  $grp_node = nycc_og_get_group_object($nid);
  if (!isset($grp_node)) {
    watchdog("nycc_og", "nycc_og_get_buttons - no NID was passed. Cancelling function.", array(), WATCHDOG_WARNING);
    return;
  }
  
  $user = nycc_get_user_object($user_id);
  if(!isset($user)) {
    watchdog("nycc_og", "nycc_og_get_buttons - Unable to load user. Cancelling function.", array(), WATCHDOG_WARNING);
    return;
  }
  $grp_max = nycc_og_get_group_max($grp_node);
  $is_confirmed = nycc_og_is_confirmed($nid, $user_id);
  $is_waiter = nycc_og_is_waiter($nid, $user_id);
  $is_captain = nycc_og_is_captain($nid, $user_id);
  $is_leader = nycc_og_is_leader($nid, $user_id);
  $is_grp_member = ($is_confirmed || $is_waiter || $is_captain || $is_leader);
  $is_paid_member = nycc_is_paid_member($user);
  $rider_count = nycc_og_count_riders($nid);
  $waiter_count = nycc_og_count_waiters($nid);
  $open_spots =  $grp_max - $rider_count;  
  $signup_time = nycc_og_get_group_signup_time($grp_node);
  $signup_enabled = REQUEST_TIME > $signup_time;
  
  $buttons = array();

  // group node properties used in building button links

  $title = $grp_node->title;
  $path = "node/$nid";
  
   /*  Register - Paid Member, not currently group member, Has available spots - Calls Join_group
   *  Add to Waitlist - Paid Member, not currently group member, No available spots - Calls Join_group
   *  Withdraw - Is rider, not leader, captain or admin - calls nycc_og_withdraw_from_group
   *  Withdraw from Waitlist - Is waitlisted, not leader, captain, or admin - calls nycc_og_withdraw_from_group
   */

   
  if (! $signup_enabled)
    $buttons[] = array(
                       'title' => "Register for  $title (Disabled)",
                       'action' => "#",
                       'message' =>"Registration opens at  $signup_time. " );
    
  if ($signup_enabled && !$is_paid_member )
   $buttons[] = array(
                       'title' => "Register for  $title (Disabled)",
                       'action' => "#",
                       'message' =>"You must be a paid member to register" );
   
    
  if ($signup_enabled && $is_paid_member && !$is_grp_member & $open_spots >0)
   $buttons[] = array(
                       'title' => "Register for  $title ($open_spots spots available)",
                       'action' => "node/$nid/join_group",
                       'message' =>"" );  
    

  if ($signup_enabled && $is_paid_member && !$is_grp_member & $open_spots < 1)
   $buttons[] = array(
                       'title' => "Waitlist for  $title ($waiter_count members on waitlist)",
                       'action' => "node/$nid/join_group",
                       'message' =>"" );

  if ($is_confirmed && !$is_leader && !$is_captain)
   $buttons[] = array(
                       'title' => "Withdraw from  $title (You will lose your confirmed spot!)",
                       'action' => "node/$nid/withdraw_group",
                       'message' =>"" );  

  if ($is_waiter && !$is_leader && !$is_captain) 
   $buttons[] = array(
                       'title' => "Withdraw from  $title (You will lose your spot on the waitlist!)",
                       'action' => "node/$nid/withdraw_group",
                       'message' =>"" );  

  return $buttons;
}

function nycc_og_get_avail_spots_as_string($gid) {
  $grp_max = nycc_og_get_group_max($gid);
  $rider_count = nycc_og_count_riders($gid);
  $waiter_count = nycc_og_count_waiters($gid);
  $avail_spots = $grp_max - $rider_count;
    
    
  return $avail_spots > 0 ? "$avail_spots of $grp_max spot(s)" : "$waiter_count member(s) on waiting list";
}


function nycc_og_get_group_leaders($gid) {
  $rid = variable_get('nycc_og_leader_role_id', '4');
  return nycc_get_user_full_name_multiple(nycc_og_get_users_by_roles($gid, array($rid)));  
}


function nycc_og_get_group_captains($gid) {
  $rid = variable_get('nycc_og_captain_role_id', '6');
  return nycc_get_user_full_name_multiple(nycc_og_get_users_by_roles($gid, array($rid)));  
}

function nycc_og_get_group_waiters($gid) {
  $rid = variable_get('nycc_og_waiter_role_id', '7');
  return nycc_get_user_full_name_multiple(nycc_og_get_users_by_roles($gid, array($rid)));  
}

function nycc_og_get_group_riders($gid) {
  $rid = variable_get('nycc_og_rider_role_id', '5');
  return nycc_get_user_full_name_multiple(nycc_og_get_users_by_roles($gid, array($rid)));  
}


//END DISPLAY FUNCTIONS









function nycc_og_get_role_id_from_name($gid, $role_name) {
  if(is_object($gid))
    $gid = $gid->nid;
    
  $roles = og_roles('node', 'Group', $gid);
  if(isset($roles)) {
    foreach($roles as $idx => $role) {
      if (strcasecmp($role, $role_name) ==0) {
        return $idx;
      }
    }
  }
  return 0;
}


function nycc_og_count_riders($gid) {
  $rid = variable_get('nycc_og_rider_role_id', '5');
  return count(nycc_og_get_users_by_roles($gid, array($rid)));  
}

function nycc_og_count_waiters($gid) {
  $rid = variable_get('nycc_og_waiter_role_id', '7');
  return count(nycc_og_get_users_by_roles($gid, array($rid)));  
}



function nycc_og_get_user_count_by_role($gid, $rid) {
  return count(nycc_og_get_users_by_roles($gid, array($rid)));
}




function nycc_og_get_users_by_roles($gid, $rids = array()) {
  if(is_object($gid))
    $gid = $gid->nid;

      
  if(!is_array($rids))
    $rids = array($rids);
    
  $query = db_select('og_users_roles', 'og_users_roles');
  $query->fields('og_users_roles', array('uid'))->condition('gid', $gid);
  if (!empty($rids)) {
    $query->condition('rid', $rids, 'IN');
  }
  $q = $query->execute()->fetchAll();
  return $q;
}

///* returns a group object if one can be found with NID and/or VID
// */
function nycc_og_get_group_object($nid=null, $vid=null, $reset = FALSE){
  if (is_object($nid) && $nid->type =='group')
    return $nid;

  if (is_numeric($nid) && ($nid > 0)){
    $group =  node_load( $nid, $vid, $reset);
    if(is_object($group) && $group->type='group')
      return $group;
  }
  else
    return null;
}

/* returns a group object's max rider count. if there's no value set then it returns 0
 */
function nycc_og_get_group_max($gid) {
  if(is_object($gid))
    $grp_node = $gid;
  else
    $grp_node = nycc_og_get_group_object($gid);
  
  $max_count = 0;
  if(isset($grp_node)) {
    $max_count = nycc_field_get_property_text_value($grp_node, 'field_group_max_participants'); 
  }
  return $max_count != '' ? $max_count : 0;
}

function nycc_og_get_group_signup_time($gid) {
  if(is_object($gid))
    $grp_node = $gid;
  else
    $grp_node = nycc_og_get_group_object($gid);
    
  $grp_node = nycc_og_get_group_object($gid);
  $signup_time = 0;
  if(isset($grp_node)) {
    $signup_time = nycc_field_get_property_text_value($grp_node, 'field_group_reg_open_date'); 
  }
  return $signup_time != '' ? $signup_time : 0;
}


/* retrieves a group from ID and sorts the waitlisters by join date
 */
function nycc_og_get_waitlist_sorted($gid) {
  if(is_object($gid))
    $gid = $gid->nid;
    
  
  $waiter_rid = variable_get('nycc_og_waiter_role_id', '7');
  $waitlist = array();
  
  $waiters = nycc_og_get_users_by_roles($gid, $waiter_rid);
  if (empty($waiters))
    return $waitlist;
  
  foreach ($waiters as $user) {
    $membership = og_get_membership('node', $gid, 'user', $user->uid);
    if(isset($membership)) {
      if ($membership->state == 1) {
        $waitlist [] = array(
          'uid' => $membership->etid,
          'gid' => $membership->gid,
          'created' => $membership->created,
        );
      } //if active
    } //if isset
  }  //foreach
  
  foreach($waitlist as $key=>$row) {
    $created[$key] = $row['created'];
  }
  
  array_multisort($created, SORT_ASC, $waitlist);
  return $waitlist;
}

/* checks if a given user is on the waitlist for a given group
 */
function nycc_og_is_waiter($gid, $uid) {
  if(is_object($gid))
    $gid = $gid->nid;
    
   if(is_object($uid))
      $uid = $uid->uid;
      
  $waiter_rid = variable_get('nycc_og_waiter_role_id', '7');
  foreach (nycc_og_get_users_by_roles($gid, $waiter_rid) as $waiter) {
    if($waiter->uid == $uid)
      return true;
  }
  return false;
}

function nycc_og_is_member($gid, $uid) {
  $membership = og_get_membership('node', $gid, 'user', $uid);
  return is_object($membership);
}

function nycc_og_is_rider_or_waiter($gid, $uid) {
  return nycc_og_member_has_role($gid, $uid,
                                 array( variable_get('nycc_og_waiter_role_id', '7'),
                                      variable_get('nycc_og_rider_role_id', '5'))
                                 );
}

/* checks if a given user is confirmed for a given group
 */
function nycc_og_is_confirmed($gid, $uid) {
  return nycc_og_member_has_role($gid, $uid, variable_get('nycc_og_rider_role_id', '5')); 
}

/* checks if a given user is a captain for a given group
 */
function nycc_og_is_captain($gid, $uid) {
  return nycc_og_member_has_role($gid, $uid, variable_get('nycc_og_captain_role_id', '6')); 
}

/* checks if a given user is a admin for a given group
 */
function nycc_og_is_admin($gid, $uid) {
  return nycc_og_member_has_role($gid, $uid, nycc_og_get_role_id_from_name($gid, "administrator member"));
 
}

/* checks if a given user is a leader for a given group
 */
function nycc_og_is_leader($gid, $uid) {
  return nycc_og_member_has_role($gid, $uid, variable_get('nycc_og_leader_role_id', '4'));
}

function nycc_og_is_captain_or_leader_or_admin($gid, $uid) {
  return nycc_og_member_has_role($gid, $uid,
                                 array(
                                       variable_get('nycc_og_captain_role_id', '6'),
                                       variable_get('nycc_og_leader_role_id', '4'),
                                       nycc_og_get_role_id_from_name($gid, "administrator member"),
                                      )
                                 );
}

function nycc_og_member_has_role($gid, $uid, $rids) {
  if(is_object($gid))
    $gid = $gid->nid;
    
   if(is_object($uid))
      $uid = $uid->uid;
  
  if(!is_array($rids))
    $rids = array($rids);  
  
  foreach (nycc_og_get_users_by_roles($gid, $rids) as $member) {
    if($member->uid == $uid)
      return true;
  }
  return false;  
}

///* moves a user from the waitlist to confirmed by removing roles and then adding the rider role
// */
function nycc_og_confirm_waiter($gid, $uid) {
   if(is_object($gid))
    $gid = $gid->nid;
    
   if(is_object($uid))
      $uid = $uid->uid;
      
  if (variable_get('nycc_og_debug_to_log', '1') == 1) {
    $debug = TRUE;
  }
  else {
    $debug = FALSE;
  }
  
  $waiter_rid = variable_get('nycc_og_waiter_role_id', '7');
  $rider_rid = variable_get('nycc_og_rider_role_id', '5');
  
  if(nycc_og_is_waiter($gid, $uid)) {
    try{
      og_role_revoke('node', $gid, $uid, $waiter_rid);
      if($debug)
        watchdog('nycc_og', 'removing waiter role from user @uid for group @gid', array('@uid' => $uid, '@gid' => $gid, ), WATCHDOG_NOTICE);
      
      if(! nycc_og_is_confirmed($gid, $uid)) {
        og_role_grant('node', $gid, $uid, $rider_rid);
        if($debug)
          watchdog('nycc_og','Adding rider role to user @uid for group @gid', array('@uid' => $uid, '@gid' => $gid, ), WATCHDOG_NOTICE);
      }
    } catch (Exception $e) {
      watchdog('nycc_og',  'Unable to confirm waiter @uid for group @gid. Messages is <pre>@message</pre>', array('@uid' => $uid, '@gid' => $gid, '@message' => $e->getMessage()), WATCHDOG_ERROR);
    }      
  }
}

/* reviews the waitlist for a given group and moves waiters up if there is room
 */
function _nycc_og_process_waitlist($gid, $new_max = 0) {
  if(is_object($gid))
    $gid = $gid->nid;

  if (variable_get('nycc_og_debug_to_log', '1') == 1) {
    $debug = TRUE;
  }
  else {
    $debug = FALSE;
  }
  
  $waiter_rid = variable_get('nycc_og_waiter_role_id', '7');
  $rider_rid = variable_get('nycc_og_rider_role_id', '5');  
  $rider_count =nycc_og_get_user_count_by_role($gid, $rider_rid);
  $waiter_count = nycc_og_get_user_count_by_role($gid, $waiter_rid);
  
  // max can come from node or from param passed in. This allows it to be called from hook_node_update where the database tables are not yet updated
  $max_spots =  $new_max == 0 ? nycc_og_get_group_max($gid) : $new_max; 
  
  $open_spots =  $max_spots - $rider_count;
  
  if($debug)
    watchdog('nycc_og',  'Processing waitlist. max_spots is @max_spots, rider_count is @rider_count, waiter_count is @waiter_count, open_spots is @open_spots.', array('@max_spots' => $max_spots, '@rider_count' => $rider_count, '@waiter_count' => $waiter_count, '@open_spots' => $open_spots,), WATCHDOG_NOTICE) ;
  
  if ($waiter_count > 0) {
    if ($max_spots == 0) {
      //no max spots so all waiters should be moved to riders
      foreach (nycc_og_get_users_by_roles($gid, $waiter_rid) as $waiter) {
        nycc_og_confirm_waiter($gid, $waiter->uid);
      }
    }
    elseif($open_spots > 0 ) {
      $waiters = nycc_og_get_waitlist_sorted($gid);
      $i=0;
      for($i=0; $i <$open_spots; ++$i) {
        nycc_og_confirm_waiter($gid,  $waiters[$i]['uid']);
      } //for 
    } //else if
  } //if waiter count >0
}

//HOOK FUNCTIONS

function nycc_og_og_role_grant($entity_type, $gid, $uid, $rid) {
//$entity_type: The entity type of the group in which a role has been revoked.
//$gid: The group id of the group in which a role has been revoked.
//$uid: The user id of the user to whom a role has been revoked.
//$rid: The OG role id being revoked from the user.
}

function nycc_og_og_role_revoke($entity_type, $gid, $uid, $rid) {
//$entity_type: The entity type of the group in which a role has been revoked.
//$gid: The group id of the group in which a role has been revoked.
//$uid: The user id of the user to whom a role has been revoked.
//$rid: The OG role id being revoked from the user.
  if ($entity_type == 'node' && $rid == variable_get('nycc_og_rider_role_id', '5')){
    _nycc_og_process_waitlist($gid);
  }
}

function nycc_og_og_membership_delete( $og_membership) {
  if ($og_membership->entity_type == 'node'){
    _nycc_og_process_waitlist($gid);
  }  
}

//
//function nycc_og_og_membership_insert($og_membership) {
//  //if('user' == $og_membership->entity_type && is_numeric($og_membership->etid)){
//  //  $roles = og_roles('node', null, $og_membership->gid);
//  //  foreach($roles as $key => $value){
//  //    if ('rider' == $value) {
//  //      og_role_grant('node', $og_membership->gid, $og_membership->etid, $key);
//  //    }
//  //  }
//  //}
//}


function nycc_og_node_update($node) {
  
  if ($node->type == 'group') {
    $original_max = nycc_field_get_property_text_value($node->original, 'field_group_max_participants' );
    $current_max =  nycc_field_get_property_text_value($node, 'field_group_max_participants' );
    if ($original_max < $current_max) {
      watchdog('nycc_og',  'Max count changed from @orig to @curr for group @gid. Executing _nycc_og_process_waitlist().', array('@orig' => $original_max, '@curr' => $original_max, '@gid' => $node->nid), WATCHDOG_NOTICE) ;
      _nycc_og_process_waitlist($node, $current_max);
    }
  } // is group
} // nycc_og_node_update


function nycc_og_form_alter(&$form, &$form_state, $form_id)  {
  //adds validation to group node form
  if ($form_id == 'group_node_form') {
    $form['#validate'][] = 'nycc_og_check_validate';
  }
}

function nycc_og_check_validate(&$form, &$form_state)  {
  //Validation logic for group email address
  //Confirms that the domain portion of the email address matches the specified domain suffix
  //Also checks email address to ensure it's structurally valid
  if (strlen(trim($form_state['values']['field_group_email']['und'][0]['value'])) != 0) {
                             

    $mail = explode('@', $form_state['values']['field_group_email']['und'][0]['value']);
    if ( strtolower( trim($mail[1]) != strtolower(trim(variable_get('nycc_og_group_domain_suffix', ''))))) {
      form_set_error('field_group_email', 'Email addresses must end in ' . variable_get('nycc_og_group_domain_suffix' , '') 
                  . '. Please visit <a href="' . url('/admin/settings/nycc_og', array('absolute' => TRUE)) 
                  . '" target="_blank">Settings Page</a> to confirm your domain settings.');
                  
    }   
    if ( ! valid_email_address( $form_state['values']['field_group_email']['und'][0]['value'])) {
      form_set_error('field_group_email', $form_state['values']['field_group_email']['und'][0]['value']
      . " is not valid. Please enter a valid e-mail address.");
    }
  }
  
  if (strlen(trim($form_state['values']['field_group_leaders_email']['und'][0]['value'])) != 0) {
                             

    $mail = explode('@', $form_state['values']['field_group_leaders_email']['und'][0]['value']);
    if ( strtolower( trim($mail[1]) != strtolower(trim(variable_get('nycc_og_group_domain_suffix', ''))))) {
      form_set_error('field_group_leaders_email', 'Email addresses must end in ' . variable_get('nycc_og_group_domain_suffix' , '') 
                  . '. Please visit <a href="' . url('/admin/settings/nycc_og', array('absolute' => TRUE)) 
                  . '" target="_blank">Settings Page</a> to confirm your domain settings.');
                  
    }   
    if ( ! valid_email_address( $form_state['values']['field_group_leaders_email']['und'][0]['value'])) {
      form_set_error('field_group_leaders_email', $form_state['values']['field_group_leaders_email']['und'][0]['value']
      . " is not valid. Please enter a valid e-mail address.");
    }
  }
  
  
  
  //Check for updates to the Max Count and confirm that it's >= the currently registered users
    //TODO Fix this. 
    $original_max = nycc_field_get_property_text_value($node->original, 'field_group_max_participants' );
    $current_max =  nycc_field_get_property_text_value($node, 'field_group_max_participants' );
    if ($original_max != $current_max) { // if the value changed then check if it's too low
      $rider_count = nycc_og_count_riders($node->nid);
      if($rider_count < $current_max) {
        form_set_error('field_group_max_participants', 'You can not set the max lower than the currently registered rider count(' . $rider_count );
      }
    }  
}


//END HOOK FUNCTIONS
