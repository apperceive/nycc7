<?php

//TODO:
//	HOW to deal with multiple edits generate multiple approval tokens. 
//		Should probably have one value and not revision it 
//	How to load data into existing nodes


function nycc_email_menu() {
	$items = array();

  	$items['admin/settings/nycc_email'] = array(
    	'title' => 'NYCC Email',
    	'page callback' => 'drupal_get_form',
    	'page arguments' => array('nycc_email_admin_settings'),
    	'access arguments' => array('administer nycc_email'),
    	'description' => 'configure inbound nycc email',
    	'file' => 'nycc_email.admin.inc',
    	'type' => MENU_NORMAL_ITEM,
  	);

    $items['nycc/inbound'] = array(
    	'title' => t('NYCC Inbound Email'),
    	'description' => t('Inbound email'),
      	'type' => MENU_CALLBACK,
      	'page callback' => 'nycc_email_inbound_callback',
      	'access callback' => TRUE,
    );  
	return $items;
}


function nycc_email_perm() {
	return array('administer nycc_email', 'approve_rides_by_email');
} 



function nycc_email_inbound_callback() {
	if (variable_get('nycc_email_debug_to_log', '') == 1)
		$email_debug = true;
	else
		$email_debug = false;
  	
  	// Check signature.
	if(_nycc_email_isValid_signature('nycc/inbound', $_POST)) {
		//iterate through the messages
    	foreach (json_decode($_POST['mandrill_events']) as $event) {
      		$args = array(
        		'from_email' => $event->msg->from_email ?: '',
        		'from_name' => $event->msg->from_name ?: '',
        		'to_mail' => $event->msg->email ?: '',
        		'subject' => $event->msg->subject ?: '',
        		'text' => array('value' => $event->msg->text ?: '', ),
        		'raw_msg' => array('value' => $event->msg->raw_msg ?: '', ),
      		);

      	// Add type & ID.
      	$args += _nycc_email_inbound_parse_address($args['to_mail']);
      	$token = _nycc_email_parse_email($args['to_mail']);
      	
      	if ($email_debug ) watchdog('nycc_email', "Ride Token is " .  $token, array(), WATCHDOG_NOTICE) ;
		$ride = nycc_email_get_ride_from_token($token);
		if (isset($ride)) {
			if ($email_debug ) watchdog('nycc_email', "Ride found is " .  $ride->title, array(), WATCHDOG_NOTICE) ;
			if(nycc_email_can_approve_rides($args['from_email'])) {
				$ride_status = $ride->field_ride_status[0]['value'];
				if ($email_debug ) watchdog('nycc_email', 'Ride Status for Ride: ' . $ride->nid . " is " .  $ride_status, array(), WATCHDOG_NOTICE) ;	
				if($ride_status == 'Revised' || $ride_status == 'Submitted') {
					if ($email_debug ) watchdog('nycc_email', 'Ride: ' . $ride->nid . ' needs approval', array(), WATCHDOG_NOTICE) ;

					if (_nycc_email_has_approval($args['text']['value'])) {
					    $ride->field_ride_status[0]['value'] = "Approved";
					    //$ride->field_ride_additional_dates[0]['value'] = "";
					    node_save($ride);
						watchdog('nycc_email', "Ride: " . $ride->nid . " is Approved via email by: " . $args['from_email'], array(), WATCHDOG_NOTICE) ;

					} else { //is not approval
						if ($email_debug ) watchdog('nycc_email', 'Not Approving ride: ' . $ride->nid . "Start of Message is: " . $startOfMsg , array(), WATCHDOG_NOTICE) ;
						nycc_email_send_msg($args['from_email'], 
							'webmaster@nycc.org', 
							"NYCC Ride: " . $ride->title . " will not be approved" ,
							"Hello, The ride listed above will not be approved because we did not see the word Approved at the start of your reply. If you feel that this is a error, please email the NYCC Webmaster"
						);
						
					} //end if should be approved
				} else { //if ride isn't in a submitted or revised state
					if ($email_debug ) watchdog('nycc_email', 'Skipping approval of ride: ' . $ride->nid . " because it's already approved", array(), WATCHDOG_WARNING) ;
						nycc_email_send_msg($args['from_email'], 
							'webmaster@nycc.org', 
							"NYCC Ride: " . $ride->title . " was not be approved" ,
							"Hello, The ride listed above was not approved because the status is not Submitted or Revised. If you feel that this is a error, please email the NYCC Webmaster"
						);		
				} // end if ride is revised
			} else { //can not approve
				watchdog('nycc_email', 'Unauthorised approval attempt from ' . $args['from_email'], array(), WATCHDOG_ERROR) ;
				nycc_email_send_msg($args['from_email'], 
					'webmaster@nycc.org', 
					"Unable to process ride approval for Ride: " . $ride->title ,
					"Hello, We are unable to process your request to approve a ride because it was sent from an unauthorised email address. If you feel that this is a error, please email the NYCC Webmaster"
				);
					
			} // end if can approve
				
		} else { //unable to load ride from token
			watchdog('nycc_email', 'Unable to load ride from token: ' . $token, array(), WATCHDOG_ERROR) ;
			nycc_email_send_msg($args['from_email'], 
					'webmaster@nycc.org', 
					"Unable to process ride approval.",
					"Hello, We are unable to process your request to approve a ride because the ride could not be found. If you feel that this is a error, please email the NYCC Webmaster"
			);
		} //end if ride is loaded
    }//end for each
  }  else { // if email signature isn't valid.
    watchdog('nycc_email', 'Failed signature validation calculated="%calculated", received="%received",
    md5(mandrill_events)="%md5", strlen(mandrill_events)=%length, post=<pre>@post</pre>', array(
      '%calculated' => print_r($calculated_signatures, TRUE),
      '%received' => $_SERVER['HTTP_X_MANDRILL_SIGNATURE'],
      '%length' => strlen($_POST['mandrill_events']),
      '%md5' => md5($_POST['mandrill_events']),
      '@post' => print_r($_POST, TRUE),
    ), WATCHDOG_WARNING);
  } //end if valid signature
}


function _nycc_email_has_approval($text) {
	return strtolower(substr(ltrim($text),0,7)) == 'approve' ;
}



function nycc_email_send_msg($to, $from, $subject, $body) {
	if ($email_debug ) watchdog('nycc_email', 'nycc_email_send_msg called', array(), WATCHDOG_NOTICE) ;
	$headers = array(
		'MIME-Version' => '1.0',
		'Content-Type' => 'text/plain; charset=UTF-8; format=flowed; delsp=yes',
		'Content-Transfer-Encoding' => '8Bit',
		'X-Mailer' => 'Drupal',
	);
	$msg = array(
			'id' => 'test_test',
			'from' => $from,
			'to' => $to,
			'subject' => $subject,
			'body' => $body,
			'headers' => $headers,
		);
	//watchdog('nycc_email', '<pre>' .print_r( $msg, TRUE) . '</pre>');		
	drupal_mail_send($msg);
} 

function nycc_email_can_approve_rides($sender='') {
	$approvers = array();
	$sql = "select u.mail from users u  inner join users_roles ur on u.uid=ur.uid inner join role r on r.rid=ur.rid WHERE r.name in ('administer','vp of rides', 'ride coordinator')";
	$q = db_query($sql);
  	while ($records = db_fetch_array($q)) {
    	$approvers[] = $records['mail'];
  	}
  	array_push($approvers, "a-rides@nycc.org",  "b-rides@nycc.org",  "c-rides@nycc.org",  "vp-rides@nycc.org",  "webmaster@nycc.org");
  	return in_array($sender, $approvers);
}



function nycc_email_get_ride_from_token($token='') {
	if (empty($token)) {
    	return FALSE;
  	}
	$sql = "select n.nid, r.field_ride_status_value from {node} n inner join {content_type_rides} r on n.nid=r.nid and n.vid=r.vid WHERE r.field_ride_token_value = '" . $token. "' limit 1";
	$q = db_query($sql);
	$r = db_fetch_object($q);
	dpm($r);
	if (is_numeric($r->nid)) {
		if ($email_debug ) watchdog('nycc_email', 'Token: ' . $token . " returned node: " . $r->nid, array(), WATCHDOG_NOTICE) ;	
		return node_load($r->nid);
	} else {
		if ($email_debug ) watchdog('nycc_email', 'Ride could not be found for Token: ' . $token, array(), WATCHDOG_NOTICE) ;	
	}
}


function nycc_email_nycc_email_alter(&$args) {
  // Cleanup message bellow. 

  // Delete signature.
  $text = explode('--', $args['text']['value']);
  $text = $text[0];

  // Delete quotes.
  $args['text']['value'] = preg_replace("/(?<=^|\n)>.*\r?\n|\r?\n>.*/", '', $text);
}


function _nycc_email_inbound_parse_address($email = '') {
/**
 * Parse email address to get arguments for rules.
 *
 * @param string $email
 *  The email address.
 *
 * @return array
 *  Arguments: type & id.
 */
  $mail = explode('@', $email);
  $data = explode('.', $mail[0]);

  return array(
    'type' => $data[0] ?: '',
    'id' => $data[1] ?: '',
  );
}


function _nycc_email_parse_email($email = '') {
  $mail = explode('@', $email);
  return $mail[0] ?: '' ;
}


function _nycc_email_isValid_signature($urlSuffix='', $_POST=''){
	if(!empty($urlSuffix) && !empty($_POST)) {
		$url = url($urlSuffix, array('absolute' => TRUE));	
		try {
			foreach (nycc_email_mandrill_get_api_object()->request('webhooks/list') as $list) {
				if (($url == $list['url']) 
					&& (_nycc_email_generate_signature($url, $list['auth_key'], $_POST) == $_SERVER['HTTP_X_MANDRILL_SIGNATURE']))
				{
					return true;
				}
			}
		} catch (Mandrill_Exception $e) {
			watchdog('nycc_email', "_nycc_email_isValid_signature generated exception: " . $e->getMessage(), array('url' => $url,'_POST' => $_POST),  WATCHDOG_WARNING) ;	
			return false;
		}
	} else {
		watchdog('nycc_email', "_nycc_email_isValid_signature. recieved invalid parameters " , array('url' => $url,'_POST' => $_POST),  WATCHDOG_WARNING) ;	
		return false;
	}
}


function _nycc_email_generate_signature($url, $webhook_key, $params) {
/**
 * Generates a base64-encoded signature for a Mandrill webhook request.
 * Verbatim from http://help.mandrill.com/entries/23704122-Authenticating-webhook-requests
 *
 * @param string $url the webhook url
 * @param string $webhook_key the webhook's authentication key
 * @param array $params the request's POST parameters
 *
 * @return string
 */
	$signed_data = $url;
  	ksort($params);
  	foreach ($params as $key => $value) {
    	$signed_data .= $key;
    	$signed_data .= $value;
  	}
  	return base64_encode(hash_hmac('sha1', $signed_data, $webhook_key, TRUE));
}


// function _nycc_email_get_keys($url = '') {
// /**
//  * Mandrill webhook key corresponding to canonical URL.
//  * @param string $url
//  * @return array
//  */
// 	$keys = array();
//   	try {
// 		foreach (nycc_email_mandrill_get_api_object()->request('webhooks/list') as $list) {
// 			if ($url == $list['url']) {
// 		  		$keys[] = $list['auth_key'];
// 			}
// 	  	}
//   	} catch (Mandrill_Exception $e) {
//   	 	watchdog('nycc_email', "_nycc_email_get_keys generated error: " . $e->getMessage(), array(),  WATCHDOG_WARNING) ;	
//   	}
//   	return $keys;
// }

function nycc_email_mandrill_get_api_object($key='') {
	if (empty($key)) {
		$api_key = variable_get('nycc_email_mandrill_api_key', '');
	} else {
		$api_key = $key;
	}
	if (empty($api_key)) {
		//drupal_set_message("Please specify a valid API key.");
		watchdog('nycc_email', "nycc_email_mandrill_get_api_object: Unable to connect to Mandrill. API KEY is empty", array(),  WATCHDOG_WARNING) ;	
  	}
  	try {
	  	require_once('mandrill.class.php');
		$m = new Mandrill($api_key, 60);
		if (isset($m)) {
			if ($email_debug ) watchdog('nycc_email', 'Successfully connected to Mandrill', array(), WATCHDOG_NOTICE) ;	
			return $m;
		} else {
			watchdog('nycc_email', "nycc_email_mandrill_get_api_object: Unable to connect to Mandrill", array(), WATCHDOG_WARNING) ;	
  			throw $e;  		
		}  	
  	} catch(Mandrill_Exception $e) {
  		watchdog('nycc_email', "nycc_email_mandrill_get_api_object: Unable to connect to Mandrill: " . $e->getMessage(), array(), WATCHDOG_WARNING) ;
  		throw $e;	
  	}
}

function random_text( $type = 'alnum', $length = 60 )
{
	switch ( $type ) {
		case 'all':
			$pool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~!@#$%^&*()_+-|}{][;:,<.>?';
			break;
		case 'alnum':
			$pool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
			break;
		case 'alpha':
			$pool = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
			break;
		case 'hexdec':
			$pool = '0123456789abcdef';
			break;
		case 'numeric':
			$pool = '0123456789';
			break;
		case 'nozero':
			$pool = '123456789';
			break;
		case 'distinct':
			$pool = '2345679ACDEFHJKLMNPRSTUVWXYZ';
			break;
		case 'email':
			$pool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&*+-=?^_{|}~';
			break;									

		default:
			$pool = (string) $type;
			break;
	}
	$crypto_rand_secure = function ( $min, $max ) {
		$range = $max - $min;
		if ( $range < 0 ) return $min; // not so random...
		$log    = log( $range, 2 );
		$bytes  = (int) ( $log / 8 ) + 1; // length in bytes
		$bits   = (int) $log + 1; // length in bits
		$filter = (int) ( 1 << $bits ) - 1; // set all lower bits to 1
		do {
			$rnd = hexdec( bin2hex( openssl_random_pseudo_bytes( $bytes ) ) );
			$rnd = $rnd & $filter; // discard irrelevant bits
		} while ( $rnd >= $range );
		return $min + $rnd;
	};

	$token = "";
	$max   = strlen( $pool );
	for ( $i = 0; $i < $length; $i++ ) {
		$token .= $pool[$crypto_rand_secure( 0, $max )];
	}
	return $token;
}

function nycc_email_token_values($type, $object = NULL, $options = array()) {
   	$tokens = array();
   	$tokens['nycc_email_ride-auth-token'] = random_text('alnum', 60 );
	return $tokens;
}

function nycc_email_token_list($type = 'all') {
  $tokens = array();
  $tokens['node']['nycc_email_ride-auth-token'] = t("A randomly 60 charachter string used to authenticate ride approval emails.");
  return $tokens;
}


function nycc_email_views_api() {
  return array(
    'api' => 2.0,
  );  
}
